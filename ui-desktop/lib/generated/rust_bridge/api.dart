// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_web_messages_from_storage`, `handle_handshake_message`, `handle_incoming_message`, `handle_text_message`, `handle_web_message`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`

Future<String> startTor() => RustLib.instance.api.crateApiStartTor();

Future<String> getOnionAddress() =>
    RustLib.instance.api.crateApiGetOnionAddress();

Future<void> stopTor() => RustLib.instance.api.crateApiStopTor();

/// Get my own public key
Future<String> getMyPublicKey() =>
    RustLib.instance.api.crateApiGetMyPublicKey();

/// Get count of new messages since last check (for polling)
Future<int> getNewMessageCount() =>
    RustLib.instance.api.crateApiGetNewMessageCount();

Future<bool> sendMessage({
  required String onionAddress,
  required String message,
}) => RustLib.instance.api.crateApiSendMessage(
  onionAddress: onionAddress,
  message: message,
);

Future<List<ContactInfo>> getContacts() =>
    RustLib.instance.api.crateApiGetContacts();

Future<bool> addContact({
  required String onionAddress,
  required String nickname,
}) => RustLib.instance.api.crateApiAddContact(
  onionAddress: onionAddress,
  nickname: nickname,
);

/// Send a handshake message to a contact to exchange keys
Future<bool> sendHandshakeToContact({required String onionAddress}) => RustLib
    .instance
    .api
    .crateApiSendHandshakeToContact(onionAddress: onionAddress);

/// Get detailed contact information for the contact info dialog
Future<ContactDetails> getContactDetails({required String onionAddress}) =>
    RustLib.instance.api.crateApiGetContactDetails(onionAddress: onionAddress);

/// Update a contact's nickname
Future<bool> updateContactNickname({
  required String onionAddress,
  required String nickname,
}) => RustLib.instance.api.crateApiUpdateContactNickname(
  onionAddress: onionAddress,
  nickname: nickname,
);

Future<bool> deleteContact({required String onionAddress}) =>
    RustLib.instance.api.crateApiDeleteContact(onionAddress: onionAddress);

Future<List<MessageInfo>> getMessages({
  String? contactOnion,
  required int limit,
}) => RustLib.instance.api.crateApiGetMessages(
  contactOnion: contactOnion,
  limit: limit,
);

Future<List<WebMessageInfo>> getPendingWebMessages() =>
    RustLib.instance.api.crateApiGetPendingWebMessages();

Future<int> getWebMessageCount() =>
    RustLib.instance.api.crateApiGetWebMessageCount();

Future<bool> deleteChat({required String onionAddress}) =>
    RustLib.instance.api.crateApiDeleteChat(onionAddress: onionAddress);

Future<int> clearChat({required String onionAddress}) =>
    RustLib.instance.api.crateApiClearChat(onionAddress: onionAddress);

/// Detailed contact information for the contact info dialog
class ContactDetails {
  final String onionAddress;
  final String nickname;
  final String? publicKey;
  final PlatformInt64? lastSeen;
  final PlatformInt64? firstMessageTime;
  final PlatformInt64? lastMessageTime;
  final int totalMessages;

  const ContactDetails({
    required this.onionAddress,
    required this.nickname,
    this.publicKey,
    this.lastSeen,
    this.firstMessageTime,
    this.lastMessageTime,
    required this.totalMessages,
  });

  @override
  int get hashCode =>
      onionAddress.hashCode ^
      nickname.hashCode ^
      publicKey.hashCode ^
      lastSeen.hashCode ^
      firstMessageTime.hashCode ^
      lastMessageTime.hashCode ^
      totalMessages.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContactDetails &&
          runtimeType == other.runtimeType &&
          onionAddress == other.onionAddress &&
          nickname == other.nickname &&
          publicKey == other.publicKey &&
          lastSeen == other.lastSeen &&
          firstMessageTime == other.firstMessageTime &&
          lastMessageTime == other.lastMessageTime &&
          totalMessages == other.totalMessages;
}

class ContactInfo {
  final String onionAddress;
  final String nickname;
  final PlatformInt64? lastSeen;
  final String? publicKey;

  const ContactInfo({
    required this.onionAddress,
    required this.nickname,
    this.lastSeen,
    this.publicKey,
  });

  @override
  int get hashCode =>
      onionAddress.hashCode ^
      nickname.hashCode ^
      lastSeen.hashCode ^
      publicKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContactInfo &&
          runtimeType == other.runtimeType &&
          onionAddress == other.onionAddress &&
          nickname == other.nickname &&
          lastSeen == other.lastSeen &&
          publicKey == other.publicKey;
}

class MessageInfo {
  final String id;
  final String text;
  final String senderId;
  final String recipientId;
  final PlatformInt64 timestamp;
  final bool isSent;
  final bool isRead;

  const MessageInfo({
    required this.id,
    required this.text,
    required this.senderId,
    required this.recipientId,
    required this.timestamp,
    required this.isSent,
    required this.isRead,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      text.hashCode ^
      senderId.hashCode ^
      recipientId.hashCode ^
      timestamp.hashCode ^
      isSent.hashCode ^
      isRead.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          text == other.text &&
          senderId == other.senderId &&
          recipientId == other.recipientId &&
          timestamp == other.timestamp &&
          isSent == other.isSent &&
          isRead == other.isRead;
}

class WebMessageInfo {
  final String id;
  final String sender;
  final String text;
  final PlatformInt64 timestamp;

  const WebMessageInfo({
    required this.id,
    required this.sender,
    required this.text,
    required this.timestamp,
  });

  @override
  int get hashCode =>
      id.hashCode ^ sender.hashCode ^ text.hashCode ^ timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WebMessageInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          sender == other.sender &&
          text == other.text &&
          timestamp == other.timestamp;
}
